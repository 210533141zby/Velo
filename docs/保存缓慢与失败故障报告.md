# 保存缓慢与失败故障报告

## 问题: 保存文档缓慢及 "Error saving"
**日期:** 2025-12-29
**状态:** 已解决

### 问题描述
保存文档时界面一直显示 "Saving..."，随后提示 "Error saving"。后台日志显示请求开始但往往没有结束，或抛出数据库相关错误。

### 根本原因分析 (Root Cause Analysis)
1.  **ChromaDB 重复初始化 (性能)**: 每次请求都重新初始化 `Chroma` 实例。这是一个繁重的 IO 操作，导致保存接口响应极慢。
2.  **同步 IO 阻塞事件循环 (性能/超时)**: ChromaDB 的操作是同步的，在 `async` 函数中直接调用会阻塞 Python 的主事件循环，导致其他请求（如心跳检测）超时。
3.  **后台任务数据库会话失效 (错误)**:
    - 我们使用 FastAPI 的 `BackgroundTasks` 来处理日志记录 (`log_operation`)。
    - 原始代码直接将请求的数据库会话 (`db: AsyncSession`) 传递给后台任务。
    - **关键点**: 请求会话在 HTTP 响应发送后会被 FastAPI 自动关闭。当后台任务稍后尝试使用该会话写入日志时，会话已关闭，导致报错。

### 解决方案实施
1.  **单例模式**: 确保 `Chroma` 向量存储在全局仅初始化一次。
2.  **线程池卸载**: 使用 `run_in_threadpool` 将同步的 Chroma 操作放入线程池执行，不阻塞主循环。
3.  **独立会话**: 在后台任务 (`log_operation`) 中，不复用请求会话，而是创建一个新的、独立的 `AsyncSessionLocal` 实例，并使用 `async with` 管理其生命周期。

### 经验教训 (Lessons Learned)
1.  **后台任务的会话管理**: 永远不要将 HTTP 请求的数据库会话传递给后台任务。后台任务必须拥有自己独立的数据库会话。
2.  **单例的重要性**: 对于重量级资源（数据库连接、模型加载），必须使用单例模式，避免按请求创建。
3.  **Async/Sync 混合**: 在异步框架中调用同步库时，务必小心阻塞问题，使用线程池是标准的解决方案。
